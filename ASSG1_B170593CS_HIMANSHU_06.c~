#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef long long ll;
#define upto(i,a,b,inc) for(int i = a;i<=b;i+=inc)
#define downto(i,a,b,dec) for(int i = a;i>=b;i-=dec)
#define MAX 10000001
#define INF 1000000007
#define br printf("\n")

int max(int a,int b){
  return ((a>=b)?a:b);
}

struct node{
  int data;
  int h;
  int level;
  struct node *left,*right,*parent;
};

struct BST{
  struct node *root;
};

struct node *create(int item){
  struct node *tmp;
  tmp = (struct node *)malloc(sizeof(struct node));
  tmp->data = item;
  tmp->h = tmp->level = 0;
  tmp->left = tmp->right = tmp->parent =  NULL;
  return tmp;
}

struct BST *initialise(){
  struct BST *n;
  n = (struct BST *)malloc(sizeof(struct BST));
  n->root = NULL;
  return n;
}

int data(struct node *h){
  return h->data;
}

int height(struct node *curr){
  if (!curr)
    return -1;
  else{
    if (curr->left && curr->right)
      return max(curr->left->h,curr->right->h) + 1;
    else if (curr->left)
      return curr->left->h + 1;
    else if (curr->right)
      return curr->right->h + 1;
    else
      return 0;
  }
}

void fixHeight(struct node *curr){
  if (curr->left && curr->right)
    curr->h = max(height(curr->left),height(curr->right)) + 1;
  else if (curr->left)
    curr->h = height(curr->left) + 1;
  else if (curr->right)
    curr->h = height(curr->right) + 1;
  else
    curr->h = 0;
}

void setHeight(struct node *curr){
  while (curr){
    fixHeight(curr);
    curr = curr->parent;
  }
}

struct node *insert(struct node *root,int item)
{
  if (!root)
    {
      struct node *n;
      n = create(item);
      root = n;
      setHeight(root);
    }
  else if (item <= data(root))
    {
      struct node *tmp;
      tmp = insert(root->left,item);
      root->left = tmp;
      tmp->parent = root;
      setHeight(root);
      tmp->level = tmp->parent->level + 1;
    }
  else if (item > data(root))
    {
      struct node *tmp;
      tmp = insert(root->right,item);
      root->right = tmp;
      tmp->parent = root;
      setHeight(root);
      tmp->level = tmp->parent->level + 1;
    }
  return root;
}

int diameter(struct node *root){
  if (!root)
    return 0;
  else
    return max(2 + height(root->left) + height(root->right),max(diameter(root->left),diameter(root->right)));
}

int*maxwidthUtil(struct node *root,int *arr,int m){
  if (root){
    arr[m - root->level]++;
    maxwidthUtil(root->left,arr,m);
    maxwidthUtil(root->right,arr,m);
    return arr;
  }
}

int maxwidth(struct node *root){
  int *arr,mx = 0;
  arr = (int *)malloc(sizeof(int)*(height(root)+1));
  arr = maxwidthUtil(root,arr,height(root));
  upto(i,0,height(root),1)
    mx = max(mx,arr[i]);
  return mx;
}

void preorder0(struct node *root){
  if (root){
    printf("%d(",root->data);
    preorder0(root->left);
    printf()
    preorder0(root->right);
  }
}
void preorder(struct node *root,FILE *ft){
  if (root){
    fprintf(ft,"%d ",root->data);
    preorder(root->left,ft);
    preorder(root->right,ft);
  }
}

int main(){
  struct BST *myset;
  myset = initialise();
  int n;
  scanf("%d",&n);
  upto(i,1,n,1){
    int a;
    scanf("%d",&a);
    myset->root = insert(myset->root,a);
  }
  printf("%d %d %d\n",height(myset->root),diameter(myset->root),maxwidth(myset->root));
  return 0;
}
